;; implementation of A* algorithm.
;; relies on the following externally provided entities:
;; node: a breed with the following own variables:
;;	node-id		an integer id
;;	node-out		an agentset of breed road, corresponding to the directed paths from this node.
;;
;; rlink: a breed with the following own variables, linking two nodes:
;;	rlink-n1				node at the far end of the road
;;	rlink-traveltime		estimated time along road.
;;
;; max-node-id	maximum value of any node-id
;;
;; heuristic-traveltime:
;;	a reporter that reports an estimated travel time between two arbitrary nodes.
;;	given linear space, if it reports the straight-line time between them (i.e. shortest possible)
;;	the algorithm will report the shortest path; overestimating the time will
;;	result in progressively worse, but faster performance.
;;
;; node-table: table mapping from node strings to node turtles (only used for convenience in find-path)

to-report get-mark [n mark]
	let id [node-id] of n
	let m array2:item mark id
	if m != [] [
		report m
	]
;;print (word "making newm " n)
	set m newm
	setm-open m false
	setm-closed m false
	setm-parent m nobody
	setm-n m n
	array2:set mark id m
	report m
end

to-report find-path [n0 n1 wet-links threshold-depth]
	if wet-links = [] [
		set wet-links table:make
	]
	if is-string? n0 [
		set n0 table:get node-table n0
	]
	if is-string? n1 [
		set n1 table:get node-table n1
	]
	let mark (array2:new max-node-id [])
	if (n0 = n1) [
		report []			;; XXX can't tell this result from no path (except by comparing n0=n1)
	]
	let open pq:new
if n0 = nobody [
abort "n0 is nobody!"
]
	let n0m get-mark n0 mark
	pq:add open 0 n0m
	setm-open n0m true

	loop [
		if pq:length open = 0 [
			report []
		]
		let nm pq:remove open

		setm-open nm false
		setm-closed nm true;

		let n (getm-n nm)
		if(n = n1) [
			let rl (getm-rlink nm)
			let p []
			;; backtrack to start, saving links as we go.
			loop [
				set p (fput rl p)
				set n [rlink-n0] of rl
				if (n = n0) [
					report p
				]
				set rl (getm-rlink (array2:item mark ([node-id] of n)))
			]
		]
		ask [node-out] of n [
			let blocked? (table:has-key? wet-links who) and (table:get wet-links who) > threshold-depth
			if not blocked? [
				let m rlink-n1
if m = nobody [
print (word "-- " self " has n1 = nobody!")
]
				let mm get-mark m mark
				let f (getm-g nm) + [road-traveltime] of rlink-road
	
				if (getm-open mm) and f < (getm-g mm) [
					pq:delete-item open mm
					setm-open mm false
				]
				;; only happens when h is not admissible
				if (getm-closed mm) and f < (getm-g mm) [
					setm-closed mm false
				]
				if not (getm-open mm) and not (getm-closed mm) [
					setm-g mm f
					setm-rank mm (f + (heuristic-traveltime (getm-n mm) n1))
					setm-parent mm n
					setm-rlink mm self
					pq:add open (- (getm-rank mm)) mm
					setm-open mm true
				]
			]
		]
	]
end

to-report disconnected-nodes []
	ask nodes [set node-connected? false]
	traverse-node
	report nodes with [not node-connected?]
end

to-report connected-nodes []
	ask nodes [set node-connected? false]
	traverse-node
	report nodes with [node-connected?]
end

to traverse-node []
	if not node-connected? [
		set node-connected? true
		ask turtle-set [rlink-n1] of node-out [
			traverse-node
		]
	]
end

to-report node-roads []
	report turtle-set [rlink-road] of node-out
end
;; ask turtle-set [node-roads] of turtle-set [connected-nodes] of [disconnected-nodes] of (nearest-node 134 99) [colour-road self red]


;; # Edit -+,/^$/x/^;;/d
;; 	n=0
;;	for(i in n rank g open closed parent rlink){
;;		echo 'to-report getm-'^$i^' [m] report array2:item m '^$n^' end'
;;		echo 'to setm-'^$i^' [m v] array2:set m '^$n^' v end'
;;		n = `{fc $n 1 +}
;;	}
;;	echo to-report newm report array2:new $n 0.0 end
;;

;; auto-generated by above script from here:
to-report getm-n [m] report array2:item m 0 end
to setm-n [m v] array2:set m 0 v end
to-report getm-rank [m] report array2:item m 1 end
to setm-rank [m v] array2:set m 1 v end
to-report getm-g [m] report array2:item m 2 end
to setm-g [m v] array2:set m 2 v end
to-report getm-open [m] report array2:item m 3 end
to setm-open [m v] array2:set m 3 v end
to-report getm-closed [m] report array2:item m 4 end
to setm-closed [m v] array2:set m 4 v end
to-report getm-parent [m] report array2:item m 5 end
to setm-parent [m v] array2:set m 5 v end
to-report getm-rlink [m] report array2:item m 6 end
to setm-rlink [m v] array2:set m 6 v end
to-report newm report array2:new 7 0.0 end
